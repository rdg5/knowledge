# Kubernetes

## Notes

- `k` is an alias setup in my `.zshrc` for `kubectl`

### Namespaces

- Namespace is a logical grouping of resources. It isolates groups in a cluster
- Creating new namespaces can be done by `k create namespace ${nameSpaceName}`
- Deleting a namespace can be done by `k delete namespace ${nameSpaceName}` it also deletes the resources inside, so for testing it's always a great practice to create a test namespace and later on delete it
- Setting a namespace as current one (equivalent of `USE DATABASE` in SQL) can be done by: `k config set-context --current --namespace=${nameOfExistingNamespace}`

### Pods

- Good way of explaining it to students: `Operating System of the cloud`
- For generating a barebone yaml for a pod, the fastest way is: `k run nginx-yaml --image=nginx --dry-run=client -o yaml > nginx.yaml`
- To delete pods, we can use: `k delete pod ${nameOfPod}`
- To get into the pod we use: `k exec -it ${nameOfPod} -- /bin/bash`, same as docker containers
- Strategy `RollingUpdate` is the default, it's the strategy which waits for the update and then removes the old pods
- If there is no `-n` attribute refering to the namespace, the pod gets run in `default` automatically
- Port forwarding can be done with `k port-forward ${podName} ${portNumber}`

### Networking

- Kubernetes achieves pods seeing each other through the usage of a CNI plugin, which is a `Container Networking Interface`
- Most used CNI plugins are:
  - Cilium
  - Calico
  - Flannel

#### Services

- A service is a grouping of Pods
- The missing step between pods and services is generating a deployment, it can be done by doing: `k create deployment ${nameOfDeployment} --image=nginx --dry-run=client -o yaml > deployment.yaml` and then changing the ports and the image
- `k expose` generates a service by itself
- A yaml description can be generated by running: `k get services ${nameOfService} -o yaml > service.yaml` command for a running service.
- The easiest way to make a service accesible on an externalIP is by generating a yaml for it and chaning the type of it to: `type:LoadBalancer` which is going to expose the service on an externalIP while also keeping it running so you don't need to port-forward it, which has to be put in the background in order not to get cancelled
- In Rancher the externalIP works only if the preferences has the administrative rights ticked in

### Note to Self

- Do a raw deployment, change image and ports. Apply, it runs it as a svc, then generate ervice description, change type to `LoadBalancer` -> apply -> get access on externalIP

## Links
